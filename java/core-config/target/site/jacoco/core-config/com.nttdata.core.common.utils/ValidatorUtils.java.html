<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="es"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>ValidatorUtils.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">core-config</a> &gt; <a href="../index.html" class="el_bundle">core-config</a> &gt; <a href="index.source.html" class="el_package">com.nttdata.core.common.utils</a> &gt; <span class="el_source">ValidatorUtils.java</span></div><h1>ValidatorUtils.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright (C) 2023 NTT DATA, All Rights Reserved
 *******************************************************************************/
package com.nttdata.core.common.utils;

import java.util.Collection;
import java.util.function.Function;
import java.util.function.Predicate;

import org.apache.commons.beanutils.PropertyUtils;
import org.springframework.lang.Nullable;
import org.springframework.util.Assert;
import org.springframework.validation.Errors;

import com.nttdata.core.combos.model.Combo;
import com.nttdata.core.common.constants.CommonConstants;
import com.nttdata.core.i18n.constants.I18nConstants;

import lombok.extern.slf4j.Slf4j;

/**
 * Validation util class extending {@link org.springframework.validation.ValidationUtils}
 * with more validation methods for dates, ranges, sizes...
 * 
 * @author NTT DATA
 * @since 0.0.1
 */
<span class="nc" id="L28">@Slf4j</span>
public abstract class ValidatorUtils extends org.springframework.validation.ValidationUtils {
	
	private static final String ERRORS_OBJECT_MUST_NOT_BE_NULL = &quot;Errors object must not be null&quot;;

	/** Private constructor */
	private ValidatorUtils() {
	}
	
	/**
	 * Reject the given field if the value length is higher than &lt;code&gt;maxLength&lt;/code&gt; parameter.
	 * @param errors the {@code Errors} instance to register errors on
	 * @param field the field name to check
	 * @param maxLength the maximum length allowed for the field
	 */
	public static void rejectIfLengthExceeded(Errors errors, String field, long maxLength) {
<span class="nc" id="L44">		rejectIfLengthExceeded(errors, field, maxLength, I18nConstants.I18N_VALIDATION_FIELD_MAXLENGTH,</span>
<span class="nc" id="L45">				new Object[] {getFullFieldName(errors, field), maxLength}, null);</span>
<span class="nc" id="L46">	}</span>
	
	/**
	 * Reject the given field with the given error code, error arguments
	 * and default message if the value length is higher than &lt;code&gt;maxLength&lt;/code&gt; parameter.
	 * @param errors the {@code Errors} instance to register errors on
	 * @param field the field name to check
	 * @param maxLength the maximum length allowed for the field
	 * @param errorCode the error code, interpretable as message key
	 * @param errorArgs the error arguments, for argument binding via MessageFormat
	 * (can be {@code null})
	 * @param defaultMessage fallback default message
	 */
	public static void rejectIfLengthExceeded(Errors errors, String field, long maxLength, String errorCode,
			@Nullable Object[] errorArgs, @Nullable String defaultMessage) {

<span class="nc" id="L62">		Assert.notNull(errors, ERRORS_OBJECT_MUST_NOT_BE_NULL);</span>
<span class="nc" id="L63">		Object value = errors.getFieldValue(field);</span>
<span class="nc bnc" id="L64" title="All 4 branches missed.">		if (value != null &amp;&amp; value.toString().length() &gt; maxLength) {</span>
<span class="nc" id="L65">			errors.rejectValue(field, errorCode, errorArgs, defaultMessage);</span>
		}
<span class="nc" id="L67">	}</span>
	
	/**
	 * Reject the given field if the value is empty.
	 * &lt;p&gt;An 'empty' value in this context means either null,
	 * the empty string &quot;&quot;, or consisting wholly of whitespace. 
	 * &lt;p&gt;The object whose field is being validated does not need to be passed
	 * in because the {@link Errors} instance can resolve field values by itself
	 * (it will usually hold an internal reference to the target object).
	 * @param errors the {@code Errors} instance to register errors on
	 * @param field the field name to check
	 */
	public static void rejectIfEmpty(Errors errors, String field) {
<span class="nc" id="L80">		rejectIfEmptyOrWhitespace(errors, field, I18nConstants.I18N_VALIDATION_FIELD_REQUIRED, new Object[] {getFullFieldName(errors, field)}, null);</span>
<span class="nc" id="L81">	}</span>
	
	/**
	 * Reject the given field if the value is a null or empty collection.
	 * @param errors the {@code Errors} instance to register errors on
	 * @param field the field name to check
	 */
	public static void rejectIfEmptyCollection(Errors errors, String field) {
<span class="nc" id="L89">		rejectIfEmptyCollection(errors, field, I18nConstants.I18N_VALIDATION_FIELD_REQUIRED, new Object[] {getFullFieldName(errors, field)}, null);</span>
<span class="nc" id="L90">	}</span>
	
	/**
	 * Reject the given field with the given error code, error arguments
	 * and default message if the value is a null or empty collection.
	 * @param errors the {@code Errors} instance to register errors on
	 * @param field the field name to check
	 * @param errorCode the error code, interpretable as message key
	 * @param errorArgs the error arguments, for argument binding via MessageFormat
	 * (can be {@code null})
	 * @param defaultMessage fallback default message
	 */
	public static void rejectIfEmptyCollection(Errors errors, String field, String errorCode,
			@Nullable Object[] errorArgs, @Nullable String defaultMessage) {

<span class="nc" id="L105">		Assert.notNull(errors, ERRORS_OBJECT_MUST_NOT_BE_NULL);</span>
<span class="nc" id="L106">		Object value = errors.getFieldValue(field);</span>
<span class="nc bnc" id="L107" title="All 6 branches missed.">		if (value == null || (value instanceof Collection &amp;&amp; ((Collection&lt;?&gt;) value).isEmpty())) {</span>
<span class="nc" id="L108">			errors.rejectValue(field, errorCode, errorArgs, defaultMessage);</span>
		}
<span class="nc" id="L110">	}</span>
	
	/**
	 * Reject the given field if the value or values of the field (if is a {@link Collection} 
	 * is not present in &lt;code&gt;combos&lt;/code&gt; collection.
	 *
	 * @param errors the {@code Errors} instance to register errors on
	 * @param field the field name to check
	 * @param combos {@link Collection}&amp;lt;{@link Combo}&amp;gt; to validate field values
	 */
	public static void rejectIfCollectionNotContains(Errors errors, String field, Collection&lt;Combo&gt; combos) {
<span class="nc" id="L121">		rejectIfCollectionNotContains(errors, field, combos, false);</span>
<span class="nc" id="L122">	}</span>
	
	/**
	 * Reject the given field if the value or values of the field (if is a {@link Collection} 
	 * is not present in &lt;code&gt;combos&lt;/code&gt; collection.
	 *
	 * @param errors the {@code Errors} instance to register errors on
	 * @param field the field name to check
	 * @param combos {@link Collection}&amp;lt;{@link Combo}&amp;gt; to validate field values
	 * @param filterByValue checks the provided value against Combo::getValue instead Combo::getKey. Defaults to false.
	 */
	public static void rejectIfCollectionNotContains(Errors errors, String field, Collection&lt;Combo&gt; combos, boolean filterByValue) {
<span class="nc" id="L134">		rejectIfCollectionNotContains(errors, field, null, null, combos, filterByValue);</span>
<span class="nc" id="L135">	}</span>
	
	/**
	 * Reject the given field if the value or values of the field (if is a {@link Collection} 
	 * is not present in &lt;code&gt;combos&lt;/code&gt; collection.
	 * 
	 * @param &lt;T&gt; the value type
	 * @param errors the {@code Errors} instance to register errors on
	 * @param field the field name to check
	 * @param val the value to check
	 * @param propertyName {@link String} the property name inside field where value to validate is stored
	 * @param combos {@link Collection}&amp;lt;{@link Combo}&amp;gt; to validate field values
	 */
	public static &lt;T&gt; void rejectIfCollectionNotContains(Errors errors, String field, T val, String propertyName, Collection&lt;Combo&gt; combos) {
<span class="nc" id="L149">		rejectIfCollectionNotContains(errors, field, val, propertyName, combos, false);</span>
<span class="nc" id="L150">	}</span>
	
	/**
	 * Reject the given field if the value or values of the field (if is a {@link Collection} 
	 * is not present in &lt;code&gt;combos&lt;/code&gt; collection.
	 * 
	 * @param &lt;T&gt; the value type
	 * @param errors the {@code Errors} instance to register errors on
	 * @param field the field name to check
	 * @param val the value to check
	 * @param propertyName {@link String} the property name inside field where value to validate is stored
	 * @param combos {@link Collection}&amp;lt;{@link Combo}&amp;gt; to validate field values
	 * @param filterByValue checks the provided value against Combo::getValue instead Combo::getKey. Defaults to false.
	 */
	public static &lt;T&gt; void rejectIfCollectionNotContains(Errors errors, String field, T val, String propertyName, Collection&lt;Combo&gt; combos, boolean filterByValue) {
<span class="nc" id="L165">		Object value = val;</span>
<span class="nc bnc" id="L166" title="All 2 branches missed.">		if (null == value) {</span>
<span class="nc" id="L167">			value = errors.getFieldValue(field);</span>
		}
<span class="nc bnc" id="L169" title="All 2 branches missed.">		if (value instanceof Collection) {</span>
<span class="nc bnc" id="L170" title="All 2 branches missed.">			for (Object v : (Collection&lt;?&gt;) value) {</span>
<span class="nc" id="L171">				rejectIfCollectionNotContains(errors, field, combos, getPropertyValue(propertyName, v), filterByValue);</span>
<span class="nc" id="L172">			}</span>
		} else {
<span class="nc" id="L174">			rejectIfCollectionNotContains(errors, field, combos, value, filterByValue);</span>
		}
<span class="nc" id="L176">	}</span>
	
	/**
	 * Reject the given field with the given error code, error arguments
	 * and default message if the value is not present in &lt;code&gt;combos&lt;/code&gt; collection.
	 * 
	 * @param &lt;T&gt; the value type
	 * @param errors the {@code Errors} instance to register errors on
	 * @param field the field name to check
	 * @param combos {@link Collection}&amp;lt;{@link Combo}&amp;gt; to validate field values
	 * @param value the value
	 * @param filterByValue checks the provided value against Combo::getValue instead Combo::getKey. Defaults to false.
	 */
	public static &lt;T&gt; void rejectIfCollectionNotContains(Errors errors, String field, Collection&lt;Combo&gt; combos, T value, boolean filterByValue) {
		
<span class="nc" id="L191">		Assert.notNull(errors, ERRORS_OBJECT_MUST_NOT_BE_NULL);</span>
<span class="nc" id="L192">		Assert.notNull(combos, &quot;Combos collection must not be null&quot;);</span>
		
<span class="nc bnc" id="L194" title="All 2 branches missed.">		if (value != null) {</span>
<span class="nc" id="L195">			Predicate&lt;? super String&gt; filter = key -&gt; key.equalsIgnoreCase(value.toString());</span>
<span class="nc bnc" id="L196" title="All 2 branches missed.">			Function&lt;? super Combo, ? extends String&gt; filterBy = filterByValue ? Combo::getName : Combo::getId;</span>
			
<span class="nc bnc" id="L198" title="All 2 branches missed.">			if (combos.stream().map(filterBy).noneMatch(filter)) {</span>
<span class="nc" id="L199">                errors.rejectValue(field, I18nConstants.I18N_VALIDATION_FIELD_INVALID,</span>
<span class="nc" id="L200">                        new Object[] {getFullFieldName(errors, field)}, null);</span>
			}		
		}
<span class="nc" id="L203">	}</span>
	
	/**
	 * Return the full path access to field
	 * &lt;br&gt;
	 * It should be: i18n. + className. + field
	 * 
	 * @param errors {@link Errors} containing the objectName
	 * @param field {@link String} the field name
	 * @return {@link String} composed field for validation
	 */
	public static String getFullFieldName(Errors errors, String field) {
<span class="nc" id="L215">		return I18nConstants.I18N_PREFIX + errors.getObjectName() + CommonConstants.DOT + field;</span>
	}
	
	/**
	 * Try to get the value under propertyName inside object.
	 * If propertyName is null or cannot get propertyName then the object is returned
	 * 
	 * @param propertyName {@link String} the property to lookup in object
	 * @param object {@link Object} the object where property is located (could be in nested objects)
	 * @return Property value or the parameter object
	 */
	private static Object getPropertyValue(String propertyName, Object object) {
<span class="nc bnc" id="L227" title="All 2 branches missed.">		if (null == propertyName) {</span>
<span class="nc" id="L228">			return object;</span>
		}
		try {
<span class="nc" id="L231">			return PropertyUtils.getNestedProperty(object, propertyName);</span>
<span class="nc" id="L232">		} catch (Exception e) {</span>
<span class="nc" id="L233">			log.info(&quot;Cannot access to request property. Returning default object&quot;, e);</span>
<span class="nc" id="L234">			return object;</span>
		}
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>